<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Bilingual Memory </title>
  <style>
    :root{
      --bg1:#f9ecff; --bg2:#e8f6ff; --ink:#1f2937; --muted:#6b7280; --accent:#8b5cf6; --accent2:#14b8a6;
      --card:#ffffff; --good:#16a34a; --bad:#ef4444; --gold:#f59e0b;
    }
    html,body{height:100%;}
    body{
      margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, "Hiragino Kaku Gothic ProN", Meiryo, sans-serif;
      color:var(--ink);
      background: radial-gradient(1200px 700px at 10% -10%, var(--bg1), transparent),
                  radial-gradient(1200px 700px at 110% 110%, var(--bg2), transparent),
                  linear-gradient(180deg, #fff, #fafbff 60%, #f7fbff);
    }
    .wrap{max-width:1100px; margin:24px auto; padding:0 16px;}
    header{display:flex; align-items:center; justify-content:space-between; gap:12px; flex-wrap:wrap;}
    h1{font-size: clamp(22px, 3vw, 34px); margin:0; line-height:1.15;}
    .sub{color:var(--muted); font-size:14px}

    .controls{display:flex; gap:12px; align-items:center; flex-wrap:wrap}
    .controls > *{font-size:14px}
    select, button, .toggle{
      border:1px solid #e5e7eb; background:#fff; border-radius:12px; padding:10px 12px; cursor:pointer;
      transition:.15s ease; box-shadow: 0 1px 0 rgba(0,0,0,.03);
    }
    button{background:linear-gradient(180deg, #fff, #f4f7ff);}
    button:hover{transform: translateY(-1px)}
    button.primary{background:linear-gradient(180deg, #fff, #ede9fe); border-color:#ddd;}

    .stats{display:flex; gap:18px; align-items:center; flex-wrap:wrap}
    .stat{background:#fff; border:1px solid #e5e7eb; border-radius:14px; padding:10px 14px; font-feature-settings: "tnum" 1, "ss02" 1;}
    .stat b{font-variant-numeric: tabular-nums;}

    .board{margin-top:16px; display:grid; gap:12px; grid-template-columns: repeat(var(--cols,4), minmax(0,1fr));}

    .card{
      position:relative; aspect-ratio: 2/3; perspective: 1000px; user-select:none;
    }
    .card button{
      position:absolute; inset:0; border:0; padding:0; background:none; cursor:pointer;
      transform-style: preserve-3d; transition: transform .45s ease;
    }
    .face{position:absolute; inset:0; border-radius:16px; display:flex; align-items:center; justify-content:center; padding:10px; backface-visibility: hidden;}

  .back {
  background: linear-gradient(135deg, #fffafc, #f0f9ff); /* ほんのりパステル背景 */
  border: 2px solid #e5e7eb;
  border-radius: 12px;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 64px;   /* 大きめナイト */
  color: rgba(139, 92, 246, 0.25); /* 薄いパステル紫 (透明度つき) */
.hidden-knight {
  color: rgba(236, 72, 153, 0.6); /* パステルピンクでちょい濃い */
  text-shadow: 0 0 8px #f9a8d4;
}

}

    .front{
      background:var(--card); border:1px solid #e5e7eb; transform: rotateY(180deg);
      display:flex; flex-direction:column; gap:8px; text-align:center;
    }
    .label{font-size: clamp(16px, 2.6vw, 24px); font-weight:700; letter-spacing:.3px}
    .lang{font-size:12px; color:var(--muted)}
    .pairhint{font-size:10px; color:#9ca3af; display:none}

    .flipped button{transform: rotateY(180deg)}
    .matched{opacity:.7; filter: saturate(.7)}

    .footer{margin:16px 0 24px; color:var(--muted); font-size:13px}

    .ribbon{display:inline-flex; align-items:center; gap:8px; background: #fff; border:1px solid #e5e7eb; padding:8px 12px; border-radius:999px}
    .ribbon .dot{width:10px; height:10px; border-radius:50%; background:var(--gold)}

    .toast{position:fixed; left:50%; bottom:24px; transform: translateX(-50%); background:#111827; color:#fff; padding:12px 16px; border-radius:12px; opacity:0; pointer-events:none; transition:.3s ease}
    .toast.show{opacity:1}

    @media (max-width: 640px){
      .board{gap:10px}
      .face{border-radius:12px}
    }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div>
        <h1>🃏 Bilingual Memory</h1>
        <div class="sub">Flip two cards. Make a <b>JP↔EN</b> pair for the <em>same concept</em>. Beware of traps like <b>light</b>（光 / 軽い）and <b>warm</b>（温かい / あったかい）😉</div>
      </div>
      <div class="controls">
        <label>Deck
          <select id="deckSize">
            <option value="8">Trap Deck — 8 pairs (16 cards)</option>
            <option value="10" selected>Trap Deck — 10 pairs (20 cards)</option>
            <option value="12">Trap Deck — 12 pairs (24 cards)</option>
          </select>
        </label>
        <label class="toggle">
          <input type="checkbox" id="debugToggle" /> Debug hints
        </label>
        <button id="newGame" class="primary">New game</button>
      </div>
    </header>

    <section class="stats" aria-live="polite" aria-atomic="true">
      <div class="stat">⏱️ Time: <b id="time">0:00</b></div>
      <div class="stat">🎯 Moves: <b id="moves">0</b></div>
      <div class="stat">✅ Matches: <b id="matches">0</b>/<b id="totalPairs">0</b></div>
      <div class="ribbon" id="status"><span class="dot"></span><span>Ready</span></div>
    </section>

    <main class="board" id="board" style="--cols:5"></main>

    <p class="footer">Tip: Two different <b>"light"</b> cards exist (same English text, different meanings). The correct pair must share the same hidden concept and be <b>JP↔EN</b> (not JP↔JP or EN↔EN).</p>
  </div>

  <div class="toast" id="toast"></div>

  <script>
  // ====== DATA ======
  // Master list of pairs (trap-focused). Each pair creates 2 cards: JA and EN.
  // If you want to tweak words, edit here.
  const MASTER_PAIRS = [
    { id: 'warm1', ja: '温かい', en: 'warm' },
    { id: 'warm2', ja: 'あったかい', en: 'warm' },
    { id: 'light1', ja: '光',     en: 'light' },
    { id: 'light2', ja: '軽い',   en: 'light' },
    { id: 'see',    ja: '見る',   en: 'see' },
    { id: 'watch',  ja: '観る',   en: 'watch' },
    { id: 'hear',   ja: '聞く',   en: 'hear' },
    { id: 'listen', ja: '聴く',   en: 'listen' },
    { id: 'fast',   ja: '速い',   en: 'fast' },
    { id: 'early',  ja: '早い',   en: 'early' },
    // Optional extras if you want 12 pairs
    { id: 'up',     ja: '上',     en: 'up' },
    { id: 'climb',  ja: '上る',   en: 'climb' },
  ];

  // ====== UTIL ======
  const $ = (q) => document.querySelector(q);
  const board = $('#board');
  const timeEl = $('#time');
  const movesEl = $('#moves');
  const matchesEl = $('#matches');
  const totalPairsEl = $('#totalPairs');
  const statusEl = $('#status');
  const deckSizeEl = $('#deckSize');
  const debugToggle = $('#debugToggle');
  const toastEl = $('#toast');

  let state = {
    deck: [], // array of card objects
    first: null, // first flipped element
    second: null, // second flipped element
    lock: false,
    moves: 0,
    matches: 0,
    totalPairs: 0,
    started: false,
    timer: null,
    secs: 0,
  };

  function shuffle(a){
    for(let i=a.length-1;i>0;i--){
      const j = Math.floor(Math.random()*(i+1));
      [a[i], a[j]] = [a[j], a[i]];
    }
    return a;
  }

  function fmtTime(s){
    const m = Math.floor(s/60); const r = s%60; return `${m}:${r.toString().padStart(2,'0')}`;
  }

  function setColsByCount(n){
    // nice grid widths for 16, 20, 24
    const cols = (n===16)?4 : (n===20)?5 : (n===24)?6 : Math.ceil(Math.sqrt(n));
    board.style.setProperty('--cols', cols);
  }

  function toast(msg){
    toastEl.textContent = msg; toastEl.classList.add('show');
    setTimeout(()=>toastEl.classList.remove('show'), 1400);
  }

  // ====== GAME BUILD ======
  function buildDeck(pairCount){
    const pairs = MASTER_PAIRS.slice(0, pairCount);
    const cards = [];
    let cid = 1;
    for(const p of pairs){
      cards.push({ cid: cid++, text: p.ja, lang: 'JP', pair: p.id });
      cards.push({ cid: cid++, text: p.en, lang: 'EN', pair: p.id });
    }
    return shuffle(cards);
  }

  function renderDeck(){
    board.innerHTML = '';
    for(const card of state.deck){
      const root = document.createElement('div');
      root.className = 'card';
      root.dataset.cid = card.cid;
      root.dataset.pair = card.pair;
      root.dataset.lang = card.lang;

      const btn = document.createElement('button');
      btn.setAttribute('aria-label', 'flip card');

      const back = document.createElement('div');
      back.className = 'face back';
      back.innerHTML = '<svg aria-hidden="true" width="64" height="64" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" style="opacity:.3"><rect x="3" y="3" width="18" height="18" rx="3"/><path d="M7 7h10M7 12h10M7 17h6"/></svg>';

      const front = document.createElement('div');
      front.className = 'face front';
      const label = document.createElement('div');
      label.className = 'label';
      label.textContent = card.text;
      const lang = document.createElement('div');
      lang.className = 'lang';
      lang.textContent = (card.lang === 'JP' ? '日本語' : 'English');
      const hint = document.createElement('div');
      hint.className = 'pairhint';
      hint.textContent = `concept: ${card.pair}`;
      front.appendChild(label); front.appendChild(lang); front.appendChild(hint);

      btn.appendChild(back); btn.appendChild(front);
      root.appendChild(btn);
      board.appendChild(root);

      btn.addEventListener('click', ()=> onFlip(root));
    }
  }

  // ====== TIMER ======
  function startTimer(){
    if(state.started) return;
    state.started = true;
    state.timer = setInterval(()=>{ state.secs++; timeEl.textContent = fmtTime(state.secs); }, 1000);
  }
  function stopTimer(){ if(state.timer){ clearInterval(state.timer); state.timer=null; } }

  // ====== GAME FLOW ======
  function onFlip(el){
    if(state.lock) return;
    if(el.classList.contains('flipped') || el.classList.contains('matched')) return;

    startTimer();
    el.classList.add('flipped');

    if(!state.first){ state.first = el; setStatus("Thinking…"); return; }
    state.second = el; state.lock = true; state.moves++; movesEl.textContent = state.moves;

    const ok = isMatch(state.first, state.second);
    if(ok){
      setTimeout(()=>{
        state.first.classList.add('matched');
        state.second.classList.add('matched');
        state.first = state.second = null; state.lock = false; state.matches++; matchesEl.textContent = state.matches;
        setStatus("Nice! It's a match ✨");
        if(state.matches === state.totalPairs){
          stopTimer(); setStatus("All matched! GG 🎉"); toast(`Finished in ${fmtTime(state.secs)} with ${state.moves} moves`);
        }
      }, 350);
    } else {
      setTimeout(()=>{
        state.first.classList.remove('flipped');
        state.second.classList.remove('flipped');
        state.first = state.second = null; state.lock = false; setStatus("Try again 😏");
      }, 700);
    }
  }

  function isMatch(a,b){
    const pa = a.dataset.pair, pb = b.dataset.pair;
    const la = a.dataset.lang, lb = b.dataset.lang;
    return pa === pb && la !== lb; // must be same concept, opposite languages
  }

  function setStatus(msg){ statusEl.querySelector('span:last-child').textContent = msg; }

  function newGame(){
    stopTimer();
    state = { deck: [], first:null, second:null, lock:false, moves:0, matches:0, totalPairs:0, started:false, timer:null, secs:0 };
    timeEl.textContent = '0:00'; movesEl.textContent = '0'; matchesEl.textContent = '0';

    const pairsWanted = parseInt(deckSizeEl.value,10);
    state.totalPairs = pairsWanted;
    totalPairsEl.textContent = pairsWanted;

    state.deck = buildDeck(pairsWanted);
    setColsByCount(state.deck.length);
    renderDeck();
    setStatus('Ready');

    // debug hints
    document.querySelectorAll('.pairhint').forEach(el=>{
      el.style.display = debugToggle.checked ? 'block' : 'none';
    });
  }

  // events
  $('#newGame').addEventListener('click', newGame);
  deckSizeEl.addEventListener('change', newGame);
  debugToggle.addEventListener('change', ()=>{
    document.querySelectorAll('.pairhint').forEach(el=>{
      el.style.display = debugToggle.checked ? 'block' : 'none';
    });
  });

  // start
  newGame();
  </script>
</body>
</html>
